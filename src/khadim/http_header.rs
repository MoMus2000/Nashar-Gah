#![allow(dead_code)]
use std::fmt;

#[derive(Debug)]
pub enum HttpHeader {
    ContentType(String),
    ContentLength(String),
    Accept(String),
    Authorization(String),
    UserAgent(String),
    CacheControl(String),
    Connection(String),
    Date(String),
    Pragma(String),
    TransferEncoding(String),
    Upgrade(String),
    Via(String),
    AcceptCharset(String),
    AcceptEncoding(String),
    AcceptLanguage(String),
    Expect(String),
    From(String),
    Host(String),
    IfMatch(String),
    IfModifiedSince(String),
    IfNoneMatch(String),
    IfRange(String),
    IfUnmodifiedSince(String),
    MaxForwards(String),
    ProxyAuthorization(String),
    Range(String),
    Referer(String),
    TE(String),
    AccessControlAllowOrigin(String),
    Age(String),
    Allow(String),
    ContentEncoding(String),
    ContentLanguage(String),
    ContentLocation(String),
    ContentMD5(String),
    ContentRange(String),
    ETag(String),
    Expires(String),
    LastModified(String),
    Link(String),
    Location(String),
    P3P(String),
    ProxyAuthenticate(String),
    RetryAfter(String),
    Server(String),
    Vary(String),
    WwwAuthenticate(String),
}

impl HttpHeader {
    pub fn as_str(&self) -> (&str, &str) {
        match self {
            HttpHeader::ContentType(value) => ("Content-Type", value),
            HttpHeader::ContentLength(value) => ("Content-Length", value),
            HttpHeader::Accept(value) => ("Accept", value),
            HttpHeader::Authorization(value) => ("Authorization", value),
            HttpHeader::UserAgent(value) => ("User-Agent", value),
            HttpHeader::CacheControl(value) => ("Cache-Control", value),
            HttpHeader::Connection(value) => ("Connection", value),
            HttpHeader::Date(value) => ("Date", value),
            HttpHeader::Pragma(value) => ("Pragma", value),
            HttpHeader::TransferEncoding(value) => ("Transfer-Encoding", value),
            HttpHeader::Upgrade(value) => ("Upgrade", value),
            HttpHeader::Via(value) => ("Via", value),
            HttpHeader::AcceptCharset(value) => ("Accept-Charset", value),
            HttpHeader::AcceptEncoding(value) => ("Accept-Encoding", value),
            HttpHeader::AcceptLanguage(value) => ("Accept-Language", value),
            HttpHeader::Expect(value) => ("Expect", value),
            HttpHeader::From(value) => ("From", value),
            HttpHeader::Host(value) => ("Host", value),
            HttpHeader::IfMatch(value) => ("If-Match", value),
            HttpHeader::IfModifiedSince(value) => ("If-Modified-Since", value),
            HttpHeader::IfNoneMatch(value) => ("If-None-Match", value),
            HttpHeader::IfRange(value) => ("If-Range", value),
            HttpHeader::IfUnmodifiedSince(value) => ("If-Unmodified-Since", value),
            HttpHeader::MaxForwards(value) => ("Max-Forwards", value),
            HttpHeader::ProxyAuthorization(value) => ("Proxy-Authorization", value),
            HttpHeader::Range(value) => ("Range", value),
            HttpHeader::Referer(value) => ("Referer", value),
            HttpHeader::TE(value) => ("TE", value),
            HttpHeader::AccessControlAllowOrigin(value) => ("Access-Control-Allow-Origin", value),
            HttpHeader::Age(value) => ("Age", value),
            HttpHeader::Allow(value) => ("Allow", value),
            HttpHeader::ContentEncoding(value) => ("Content-Encoding", value),
            HttpHeader::ContentLanguage(value) => ("Content-Language", value),
            HttpHeader::ContentLocation(value) => ("Content-Location", value),
            HttpHeader::ContentMD5(value) => ("Content-MD5", value),
            HttpHeader::ContentRange(value) => ("Content-Range", value),
            HttpHeader::ETag(value) => ("ETag", value),
            HttpHeader::Expires(value) => ("Expires", value),
            HttpHeader::LastModified(value) => ("Last-Modified", value),
            HttpHeader::Link(value) => ("Link", value),
            HttpHeader::Location(value) => ("Location", value),
            HttpHeader::P3P(value) => ("P3P", value),
            HttpHeader::ProxyAuthenticate(value) => ("Proxy-Authenticate", value),
            HttpHeader::RetryAfter(value) => ("Retry-After", value),
            HttpHeader::Server(value) => ("Server", value),
            HttpHeader::Vary(value) => ("Vary", value),
            HttpHeader::WwwAuthenticate(value) => ("WWW-Authenticate", value),
        }
    }
}

impl fmt::Display for HttpHeader {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let (name, value) = self.as_str();
        write!(f, "{}: {}", name, value)
    }
}
