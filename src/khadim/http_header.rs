#![allow(dead_code)]
use std::fmt;

#[derive(Debug)]
pub enum HttpHeader {
    ContentType(&'static str),
    ContentLength(&'static str),
    Accept(&'static str),
    Authorization(&'static str),
    UserAgent(&'static str),
    CacheControl(&'static str),
    Connection(&'static str),
    Date(&'static str),
    Pragma(&'static str),
    TransferEncoding(&'static str),
    Upgrade(&'static str),
    Via(&'static str),
    AcceptCharset(&'static str),
    AcceptEncoding(&'static str),
    AcceptLanguage(&'static str),
    Expect(&'static str),
    From(&'static str),
    Host(&'static str),
    IfMatch(&'static str),
    IfModifiedSince(&'static str),
    IfNoneMatch(&'static str),
    IfRange(&'static str),
    IfUnmodifiedSince(&'static str),
    MaxForwards(&'static str),
    ProxyAuthorization(&'static str),
    Range(&'static str),
    Referer(&'static str),
    TE(&'static str),
    AccessControlAllowOrigin(&'static str),
    Age(&'static str),
    Allow(&'static str),
    ContentEncoding(&'static str),
    ContentLanguage(&'static str),
    ContentLocation(&'static str),
    ContentMD5(&'static str),
    ContentRange(&'static str),
    ETag(&'static str),
    Expires(&'static str),
    LastModified(&'static str),
    Link(&'static str),
    Location(&'static str),
    P3P(&'static str),
    ProxyAuthenticate(&'static str),
    RetryAfter(&'static str),
    Server(&'static str),
    Vary(&'static str),
    WwwAuthenticate(&'static str),
}

impl HttpHeader {
    pub fn as_str(&self) -> (&'static str, &str) {
        match self {
            HttpHeader::ContentType(value) => ("Content-Type", value),
            HttpHeader::ContentLength(value) => ("Content-Length", value),
            HttpHeader::Accept(value) => ("Accept", value),
            HttpHeader::Authorization(value) => ("Authorization", value),
            HttpHeader::UserAgent(value) => ("User-Agent", value),
            HttpHeader::CacheControl(value) => ("Cache-Control", value),
            HttpHeader::Connection(value) => ("Connection", value),
            HttpHeader::Date(value) => ("Date", value),
            HttpHeader::Pragma(value) => ("Pragma", value),
            HttpHeader::TransferEncoding(value) => ("Transfer-Encoding", value),
            HttpHeader::Upgrade(value) => ("Upgrade", value),
            HttpHeader::Via(value) => ("Via", value),
            HttpHeader::AcceptCharset(value) => ("Accept-Charset", value),
            HttpHeader::AcceptEncoding(value) => ("Accept-Encoding", value),
            HttpHeader::AcceptLanguage(value) => ("Accept-Language", value),
            HttpHeader::Expect(value) => ("Expect", value),
            HttpHeader::From(value) => ("From", value),
            HttpHeader::Host(value) => ("Host", value),
            HttpHeader::IfMatch(value) => ("If-Match", value),
            HttpHeader::IfModifiedSince(value) => ("If-Modified-Since", value),
            HttpHeader::IfNoneMatch(value) => ("If-None-Match", value),
            HttpHeader::IfRange(value) => ("If-Range", value),
            HttpHeader::IfUnmodifiedSince(value) => ("If-Unmodified-Since", value),
            HttpHeader::MaxForwards(value) => ("Max-Forwards", value),
            HttpHeader::ProxyAuthorization(value) => ("Proxy-Authorization", value),
            HttpHeader::Range(value) => ("Range", value),
            HttpHeader::Referer(value) => ("Referer", value),
            HttpHeader::TE(value) => ("TE", value),
            HttpHeader::AccessControlAllowOrigin(value) => ("Access-Control-Allow-Origin", value),
            HttpHeader::Age(value) => ("Age", value),
            HttpHeader::Allow(value) => ("Allow", value),
            HttpHeader::ContentEncoding(value) => ("Content-Encoding", value),
            HttpHeader::ContentLanguage(value) => ("Content-Language", value),
            HttpHeader::ContentLocation(value) => ("Content-Location", value),
            HttpHeader::ContentMD5(value) => ("Content-MD5", value),
            HttpHeader::ContentRange(value) => ("Content-Range", value),
            HttpHeader::ETag(value) => ("ETag", value),
            HttpHeader::Expires(value) => ("Expires", value),
            HttpHeader::LastModified(value) => ("Last-Modified", value),
            HttpHeader::Link(value) => ("Link", value),
            HttpHeader::Location(value) => ("Location", value),
            HttpHeader::P3P(value) => ("P3P", value),
            HttpHeader::ProxyAuthenticate(value) => ("Proxy-Authenticate", value),
            HttpHeader::RetryAfter(value) => ("Retry-After", value),
            HttpHeader::Server(value) => ("Server", value),
            HttpHeader::Vary(value) => ("Vary", value),
            HttpHeader::WwwAuthenticate(value) => ("WWW-Authenticate", value),
        }
    }
}

impl fmt::Display for HttpHeader {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let (name, value) = self.as_str();
        write!(f, "{}: {}", name, value)
    }
}
